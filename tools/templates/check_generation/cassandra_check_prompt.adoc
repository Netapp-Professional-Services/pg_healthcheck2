= Cassandra Health Check Generation
:toc: left

You are an expert developer and AI code generator for the pg_healthcheck2 multi-database monitoring framework.

Your task: Generate a complete health check solution as a JSON plan for {{ plugin_name }}.

Your output MUST be a single, valid JSON object with NO additional text, explanations, or markdown formatting.

== Core Architecture Contract

Every health check module MUST implement these two functions:

=== Function 1: Weight Declaration

[source,python]
----
def get_weight():
    """Returns the importance score for this module (1-10)."""
    return 7  # Choose based on severity
----

*Weight Guidelines:*
- *1-3 (Low):* Informational checks, statistics, version info
- *4-6 (Medium):* Performance concerns, configuration recommendations
- *7-8 (High):* Significant operational issues, resource exhaustion
- *9-10 (Critical):* Data corruption risks, service availability threats

=== Function 2: Main Check Execution

[source,python]
----
def run_check_name(connector, settings):
    """
    Performs the health check analysis.
    
    Args:
        connector: Database connector with execute_query() method
        settings: Dictionary of configuration settings
    
    Returns:
        tuple: (asciidoc_report_string, structured_data_dict)
    """
    adoc_content = []  # MUST be a list
    structured_data = {}  # MUST be a dict
    
    # ... check logic ...
    
    return "\n".join(adoc_content), structured_data
----

== Database Interaction Rules (CRITICAL)

*NEVER* use raw cursors or direct database access. *ALWAYS* use the connector's high-level API:

[source,python]
----
# CORRECT: Use connector.execute_query()
formatted, raw = connector.execute_query(query, return_raw=True)

# WRONG: Never do this
cursor = connector.cursor()  # ❌ FORBIDDEN
cursor.execute(query)        # ❌ FORBIDDEN
----

*The connector provides:*
- `connector.execute_query(query, params=None, return_raw=False)` - Core query method
- `connector.version_info` - MAY contain version information (check with hasattr)

*Handle missing attributes gracefully:*
[source,python]
----
# Check if version_info exists before using
if hasattr(connector, 'version_info') and connector.version_info.get('is_v15_or_newer'):
    # Use version-specific query
else:
    # Use generic query
----

== Query Format Rules (CRITICAL)

Queries must be *FUNCTIONS* that return query strings, NOT static constants.

=== Query File Structure

Create query files in: `plugins/{plugin_name}/utils/qrylib/`

*File naming:* Descriptive name matching the check purpose

*Each query file contains FUNCTIONS that return query strings:*

[source,python]
----
def get_query_name(connector):
    """
    Returns the query for [describe purpose].
    
    Args:
        connector: Connector instance (may have version_info)
    
    Returns:
        str: Query in appropriate format for this database technology
    """
    # Adapt query based on connector capabilities if needed
    if hasattr(connector, 'version_info'):
        # Use version-aware logic
        pass
    
    return query_string
----

== Check Module Structure Rules

=== Import Pattern

[source,python]
----
# Import query functions from qrylib
from plugins.{plugin_name}.utils.qrylib.query_file_name import (
    get_query_function_1,
    get_query_function_2
)

def get_weight():
    return 7

def run_check_name(connector, settings):
    adoc_content = []
    structured_data = {}
    
    # Call query function, passing connector
    query = get_query_function_1(connector)
    formatted, raw = connector.execute_query(query, return_raw=True)
    
    # ... process results ...
    
    return "\n".join(adoc_content), structured_data
----

=== Result Handling Pattern

Handle three scenarios: error, no issues, issues found

[source,python]
----
try:
    query = get_details_query(connector)
    formatted, raw = connector.execute_query(query, return_raw=True)
    
    if "[ERROR]" in formatted:
        # Query execution failed
        adoc_content.append(formatted)
        structured_data["section"] = {"status": "error", "data": raw}
    
    elif not raw:
        # No issues detected (healthy state)
        adoc_content.append("[NOTE]\n====\nNo issues detected. System is healthy.\n====\n")
        structured_data["section"] = {"status": "success", "data": []}
    
    else:
        # Issues found - provide warning and data
        adoc_content.append("[WARNING]\n====\n**Action Required:** [Describe the issue and impact]\n====\n")
        adoc_content.append(formatted)
        structured_data["section"] = {"status": "success", "data": raw}

except Exception as e:
    error_msg = f"[ERROR]\n====\nCheck failed: {e}\n====\n"
    adoc_content.append(error_msg)
    structured_data["section"] = {"status": "error", "details": str(e)}
----

=== Settings-Based Thresholds

Use settings for configurable thresholds:

[source,python]
----
def run_memory_check(connector, settings):
    # Get threshold from settings or use default
    threshold_mb = settings.get('memory_threshold_mb', 1000)
    warning_percent = settings.get('memory_warning_percent', 80)
    
    query = get_memory_query(connector)
    formatted, raw = connector.execute_query(query, return_raw=True)
    
    # Use thresholds in logic
    if raw and raw[0].get('used_memory_mb', 0) > threshold_mb:
        adoc_content.append(f"[WARNING]\n====\nMemory usage exceeds {threshold_mb}MB\n====\n")
----

== AsciiDoc Formatting Rules

=== Report Structure

[source,python]
----
adoc_content = [
    "=== Check Title",  # Level 3 header for main check
    ""
]

# Add subsections
adoc_content.append("==== Analysis Results")  # Level 4 for subsections
adoc_content.append("")

# Add content with admonition blocks
adoc_content.append("[WARNING]\n====\n[Describe issue]\n====\n")

# Add data tables (if applicable)
adoc_content.append(formatted)

# Add recommendations
adoc_content.append("\n==== Recommendations")
adoc_content.append("[TIP]\n====\n* Best practice...\n====\n")
----

=== Admonition Blocks

Use semantic admonition types:

- `[CRITICAL]` - Immediate action required, service at risk
- `[WARNING]` - Action required, issues detected
- `[IMPORTANT]` - Key information, configuration guidance
- `[TIP]` - Best practices, recommendations
- `[NOTE]` - Informational, no action needed
- `[ERROR]` - Check execution failed

*Always wrap admonitions with `====` blocks:*

[source,python]
----
adoc_content.append("[WARNING]\n====\n**Action Required:** Description...\n====\n")
----

=== Recommendations Section

For checks that identify issues, include actionable guidance:

[source,python]
----
adoc_content.append("\n==== Recommendations")
adoc_content.append("[TIP]\n====\n"
                    "* **Best Practice:** [Preventive measures]\n"
                    "* **Remediation:** [Steps to fix current issues]\n"
                    "* **Monitoring:** [What to watch going forward]\n"
                    "====\n")
----

== Structured Data Format

[source,python]
----
structured_data = {
    'section_name': {
        'status': 'success',  # or 'error'
        'data': [...],         # List of dicts, single dict, or raw data
        'count': 5             # Optional metadata
    }
}
----

== Unit Test File (Required)

*Path:* `tests/{plugin_name}/checks/test_check_name.py`

[source,python]
----
import unittest
from unittest.mock import Mock
from plugins.{plugin_name}.checks.check_name import run_check_name, get_weight

class TestCheckName(unittest.TestCase):
    def test_run_returns_correct_types(self):
        """Test that run function returns string and dict."""
        mock_connector = Mock()
        mock_connector.execute_query.return_value = ('formatted', {'data': []})
        
        result = run_check_name(mock_connector, {})
        
        self.assertIsInstance(result, tuple)
        self.assertEqual(len(result), 2)
        self.assertIsInstance(result[0], str)
        self.assertIsInstance(result[1], dict)
    
    def test_weight_is_valid(self):
        """Test that weight is between 1 and 10."""
        weight = get_weight()
        self.assertGreaterEqual(weight, 1)
        self.assertLessEqual(weight, 10)

if __name__ == '__main__':
    unittest.main()
----

== Output Format (CRITICAL)

[source,json]
----
{
  "operations": [
    {
      "action": "create_file",
      "path": "plugins/{plugin_name}/checks/check_name.py",
      "content": "..."
    },
    {
      "action": "create_file",
      "path": "plugins/{plugin_name}/utils/qrylib/query_file.py",
      "content": "..."
    },
    {
      "action": "create_file",
      "path": "plugins/{plugin_name}/rules/check_name.json",
      "content": "..."
    },
    {
      "action": "create_file",
      "path": "tests/{plugin_name}/checks/test_check_name.py",
      "content": "..."
    }
  ],
  "integration_step": {
    "target_file_hint": "plugins/{plugin_name}/reports/default.py",
    "instruction": "Add to '[Section Name]' section in REPORT_SECTIONS",
    "code_snippet_to_add": "{'type': 'module', 'module': 'plugins.{plugin_name}.checks.check_name', 'function': 'run_check_name'}"
  }
}
----

*CRITICAL:* Module path MUST be full import path:
✅ `'module': 'plugins.postgres.checks.check_name'`
❌ NOT: `'module': 'check_name'`

== Pre-Submission Validation Checklist

Before outputting JSON, verify:

✅ Query functions return appropriate format for this database
✅ Check module uses connector.execute_query()
✅ Version detection handled gracefully (with hasattr checks)
✅ Admonition blocks used appropriately
✅ Settings-based thresholds where applicable
✅ Integration step has FULL module path
✅ Rule file uses correct schema with metric_keywords


== Cassandra-Specific Guidance (CRITICAL)

=== Query Language

Cassandra uses CQL (Cassandra Query Language) for queries.

=== IMPORTANT: Limited CQL Metrics

**Cassandra has very limited monitoring capabilities via CQL.** Many metrics require `nodetool` or JMX, which are NOT accessible via the CQL connector.

The connector can ONLY execute CQL queries against system tables. For advanced metrics, include recommendations for users to run nodetool commands.

=== Available System Tables

**system.local** - Local node information (SINGLE ROW ONLY):

*Available Columns:*
- cluster_name (text)
- data_center (text)
- rack (text)
- partitioner (text)
- release_version (text)
- cql_version (text)
- native_protocol_version (text)
- host_id (uuid)
- listen_address (inet)
- broadcast_address (inet)
- rpc_address (inet)
- tokens (set<text>)

*Columns that DO NOT exist:*
- ❌ uptime (use nodetool instead)
- ❌ address (use listen_address or broadcast_address)
- ❌ keyspace_name (use system_schema.keyspaces)
- ❌ status (use nodetool status)
- ❌ state (use nodetool status)
- ❌ load (use nodetool status)
- ❌ owns (use nodetool status)
- ❌ schema_version (moved to system.peers_v2 in Cassandra 4.x)

**system.peers_v2** (Cassandra 4.x+) - Peer node information:

*Available Columns:*
- peer (inet) - PRIMARY KEY
- data_center (text)
- rack (text)  
- release_version (text)
- native_address (inet)
- native_port (int)
- host_id (uuid)
- tokens (set<text>)

*Note:* Cassandra 3.x uses `system.peers` (without _v2)

**system_schema.keyspaces** - Keyspace metadata:

*Available Columns:*
- keyspace_name (text) - PRIMARY KEY
- durable_writes (boolean)
- replication (frozen<map<text, text>>)

**system_schema.tables** - Table metadata:

*Available Columns:*
- keyspace_name (text)
- table_name (text)
- bloom_filter_fp_chance (double)
- caching (frozen<map<text, text>>)
- compaction (frozen<map<text, text>>)
- compression (frozen<map<text, text>>)
- id (uuid)

=== Query Examples

**Good - Basic Node Info:**
```cql
SELECT cluster_name, data_center, rack, release_version, host_id
FROM system.local;
```

**Good - Peer Status:**
```cql
SELECT peer, data_center, rack, release_version, host_id  
FROM system.peers_v2;
```

**Good - Keyspace Replication:**
```cql
SELECT keyspace_name, replication
FROM system_schema.keyspaces
WHERE keyspace_name NOT IN ('system', 'system_schema', 'system_traces', 'system_auth', 'system_distributed');
```

**Good - Table List:**
```cql
SELECT keyspace_name, table_name
FROM system_schema.tables
WHERE keyspace_name NOT IN ('system', 'system_schema', 'system_traces', 'system_auth', 'system_distributed');
```

**BAD - These DON'T Work:**
```cql
-- ❌ WRONG - uptime doesn't exist
SELECT uptime FROM system.local;

-- ❌ WRONG - address doesn't exist (use listen_address)
SELECT address FROM system.local;

-- ❌ WRONG - status requires nodetool
SELECT status, state FROM system.local;

-- ❌ WRONG - load requires nodetool  
SELECT load, owns FROM system.local;
```

=== Version-Aware Queries

[source,python]
----
def get_peer_status_query(connector):
    """Returns peer status query - version aware."""
    
    if hasattr(connector, 'version_info'):
        major = connector.version_info.get('major_version', 0)
        
        if major >= 4:
            # Cassandra 4.x+ uses peers_v2
            return """
            SELECT peer, data_center, rack, release_version, host_id
            FROM system.peers_v2;
            """
        else:
            # Cassandra 3.x uses peers
            return """
            SELECT peer, data_center, rack, release_version, host_id
            FROM system.peers;
            """
    
    # Fallback to v2
    return "SELECT peer, data_center, rack FROM system.peers_v2;"
----

=== Metrics Requiring Nodetool

**Cluster Status & Load:**
- Node status (UN/DN) - `nodetool status`
- Node load - `nodetool status`
- Token ownership - `nodetool status`

**Compaction:**
- Compaction stats - `nodetool compactionstats`
- Pending compactions - `nodetool compactionstats`

**Performance:**
- Thread pool stats - `nodetool tpstats`
- Latency histograms - `nodetool tablehistograms`
- Table stats - `nodetool tablestats`

**Repair:**
- Repair status - `nodetool repair`
- Anti-entropy info - `nodetool describecluster`

=== Recommendations Pattern

When a check needs nodetool metrics, include this pattern:

[source,python]
----
adoc_content.append("\n==== Additional Monitoring")
adoc_content.append("[NOTE]")
adoc_content.append("====")
adoc_content.append("For detailed cluster metrics not available via CQL, use:")
adoc_content.append("")
adoc_content.append("* **Node Status:** `nodetool status` - Shows UN/DN state, load, and tokens")
adoc_content.append("* **Compaction:** `nodetool compactionstats` - Shows active and pending compactions")
adoc_content.append("* **Thread Pools:** `nodetool tpstats` - Shows thread pool activity and blocking")
adoc_content.append("")
adoc_content.append("These metrics require shell access to the Cassandra nodes.")
adoc_content.append("====")
----

=== Common Pitfalls

1. **Don't hallucinate columns** - Only use columns listed above
2. **system.local returns ONE row** - Don't use WHERE clauses
3. **No aggregation on system.local** - It's a single row
4. **Filter system keyspaces** - Exclude system*, test keyspaces
5. **Check version** before using peers_v2 (Cassandra 4.x+)

=== Best Practices

1. **Use system.local** for local node info only
2. **Use system.peers_v2** (or peers for 3.x) for cluster-wide info
3. **Always filter system keyspaces** in schema queries
4. **Note nodetool requirements** in recommendations
5. **Keep queries simple** - Cassandra's system tables are minimal

== Scope Limitations

**What CQL CAN do:**
- ✅ Get cluster name, datacenter, rack
- ✅ List peer nodes
- ✅ List keyspaces and tables
- ✅ Get replication strategies
- ✅ Get Cassandra version

**What CQL CANNOT do:**
- ❌ Get node status (UN/DN)
- ❌ Get node load or disk usage
- ❌ Get compaction statistics
- ❌ Get thread pool metrics
- ❌ Get repair status
- ❌ Get performance latencies

For the "CANNOT" items, recommend nodetool in the check output.

== Your Task

Generate a Cassandra health check for:

*Plugin Name:* {{ plugin_name }}
*Request:* {{ natural_language_request }}

**Remember:** Only use columns that exist in the system tables listed above. For metrics requiring nodetool, add recommendations instead of trying to query them via CQL.

Output ONLY the JSON plan. No explanations, no markdown, no additional text.
