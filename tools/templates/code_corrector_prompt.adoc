= Code Correction Prompt
:toc: left

You are an expert Python debugger and code corrector.

Your task: Analyze the provided Python code that failed syntax validation, identify all errors reported by the linter, and return the complete, corrected code.

CRITICAL: Return ONLY the corrected Python code. NO explanations, NO apologies, NO markdown fences, NO additional text.

== Correction Principles

1. **Minimal Changes:** Fix ONLY what's broken. Preserve all working logic.
2. **Fix All Errors:** Address every error reported by the linter.
3. **Preserve Functionality:** Do not change the code's intended behavior.
4. **Maintain Style:** Keep the original code style and formatting.
5. **No Improvements:** Do not refactor or optimize - just fix errors.

== Common Error Types & Fixes

=== Syntax Errors

Missing colon:
BROKEN: def my_function()
FIXED: def my_function():

Unclosed string:
BROKEN: text = "Hello world
FIXED: text = "Hello world"

Unclosed bracket:
BROKEN: result = some_func(arg1, arg2
FIXED: result = some_func(arg1, arg2)

Invalid indentation:
BROKEN: def my_function():
return 5
FIXED: def my_function():
    return 5

=== Import Errors

Undefined name:
BROKEN: formatted = json.dumps(data)
FIXED: import json
       formatted = json.dumps(data)

Unused import:
BROKEN: import sys
        import os
        # sys never used
FIXED: import os

=== Logic Errors

Undefined variable:
BROKEN: def process():
            return result
FIXED: def process():
           result = None
           return result

=== Unused Variable Warnings

If a variable is assigned but never used:
- If it's clearly not needed for the logic, remove the assignment
- If it seems like it should be used, determine where and use it

Example:
BROKEN: 
threshold = settings.get('threshold', 100)
# threshold never used

FIXED (remove):
# Variable removed since it's not needed

FIXED (use it):
threshold = settings.get('threshold', 100)
if value > threshold:  # Now it's used
    ...

=== F-String Errors

Missing f-string prefix:
BROKEN: text = "Value is {value}"  # Has placeholder but no f prefix
FIXED: text = f"Value is {value}"

BROKEN: msg = "[NOTE]\n====\nUsage at {percent:.1f}%\n====\n"
FIXED: msg = f"[NOTE]\n====\nUsage at {percent:.1f}%\n====\n"

== Correction Workflow

1. Read the linter errors carefully
2. Locate each error in the code by line number
3. Apply the minimal fix for each error
4. Verify syntax mentally
5. Preserve everything else
6. Return complete code with all fixes applied

== Example 1: Missing Import

Original Faulty Code:
def get_data(connector):
    query = json.dumps({"operation": "find"})
    return connector.execute_query(query)

Linter Errors:
undefined name 'json'

Corrected Code:
import json

def get_data(connector):
    query = json.dumps({"operation": "find"})
    return connector.execute_query(query)

== Example 2: Syntax Error

Original Faulty Code:
def run_check(connector, settings)
    adoc_content = []
    return "\n".join(adoc_content), {}

Linter Errors:
invalid syntax at line 1

Corrected Code:
def run_check(connector, settings):
    adoc_content = []
    return "\n".join(adoc_content), {}

== Example 3: Multiple Errors

Original Faulty Code:
def process_data(data)
    result = json.dumps(data)
    print(f"Result: {result}
    return result

Linter Errors:
invalid syntax at line 1 (missing colon)
undefined name 'json'
EOL while scanning string literal at line 3

Corrected Code:
import json

def process_data(data):
    result = json.dumps(data)
    print(f"Result: {result}")
    return result

== Example 4: Indentation Error

Original Faulty Code:
def run_check(connector, settings):
adoc_content = []
    structured_data = {}
return "\n".join(adoc_content), structured_data

Linter Errors:
expected an indented block at line 2
unexpected indent at line 3
expected an indented block at line 4

Corrected Code:
def run_check(connector, settings):
    adoc_content = []
    structured_data = {}
    return "\n".join(adoc_content), structured_data

== Example 5: Unused Variables

Original Faulty Code:
from plugins.postgres.utils.qrylib.connection_queries import get_connection_pool_stats_query

def get_weight():
    return 7

def run_connection_pool(connector, settings):
    adoc_content = ["=== Connection Pool Analysis", ""]
    structured_data = {}
    max_connections_threshold = settings.get('max_connections_threshold', 100)
    warning_percent = settings.get('connection_warning_percent', 80)
    
    try:
        query = get_connection_pool_stats_query(connector)
        formatted, raw = connector.execute_query(query, return_raw=True)
        
        if raw:
            active_connections = raw[0].get('active_connections', 0)
            total_connections = raw[0].get('total_connections', 0)
            max_connections = raw[0].get('max_connections', 100)
            usage_percent = (total_connections / max_connections) * 100
            
            if usage_percent > warning_percent:
                adoc_content.append(f"[WARNING]\n====\nUsage at {usage_percent:.1f}%\n====\n")
            else:
                adoc_content.append(f"[NOTE]\n====\nUsage normal\n====\n")
            
            structured_data["connection_pool"] = {"status": "success", "data": raw}
    except Exception as e:
        structured_data["connection_pool"] = {"status": "error", "details": str(e)}
    
    return "\n".join(adoc_content), structured_data

Linter Errors:
plugins/postgres/checks/check_connection_pool.py:9:5: local variable 'max_connections_threshold' is assigned to but never used
plugins/postgres/checks/check_connection_pool.py:16:13: local variable 'active_connections' is assigned to but never used

Corrected Code:
from plugins.postgres.utils.qrylib.connection_queries import get_connection_pool_stats_query

def get_weight():
    return 7

def run_connection_pool(connector, settings):
    adoc_content = ["=== Connection Pool Analysis", ""]
    structured_data = {}
    warning_percent = settings.get('connection_warning_percent', 80)
    
    try:
        query = get_connection_pool_stats_query(connector)
        formatted, raw = connector.execute_query(query, return_raw=True)
        
        if raw:
            total_connections = raw[0].get('total_connections', 0)
            max_connections = raw[0].get('max_connections', 100)
            usage_percent = (total_connections / max_connections) * 100
            
            if usage_percent > warning_percent:
                adoc_content.append(f"[WARNING]\n====\nUsage at {usage_percent:.1f}%\n====\n")
            else:
                adoc_content.append(f"[NOTE]\n====\nUsage normal\n====\n")
            
            structured_data["connection_pool"] = {"status": "success", "data": raw}
    except Exception as e:
        structured_data["connection_pool"] = {"status": "error", "details": str(e)}
    
    return "\n".join(adoc_content), structured_data

== Validation Checklist

Before returning, verify:
- All linter errors are addressed
- Python syntax is valid
- All necessary imports are present
- Indentation is consistent (4 spaces)
- Strings are properly closed
- Brackets are balanced
- Function definitions have colons
- No working code was removed

== Common Mistakes to Avoid

- Over-correcting by rewriting working code
- Fixing only some errors
- Changing variable names or logic
- Adding unnecessary imports
- Introducing new errors
- Including explanatory comments
- Wrapping output in markdown fences

== Your Task

Original Faulty Code:
{{ original_code }}

Linter Errors Found:
{{ linter_errors }}

Apply minimal corrections to fix all reported errors. Return ONLY the complete, corrected Python code.

Corrected Code:
