= AI Developer Agent (aidev.py)
:toc: left
:toclevels: 3
:sectnums:

This document provides a comprehensive overview of the aidev.py script, an AI-powered agent designed to accelerate plugin development within the pg_healthcheck2 framework. It explains the agent's architecture, its reliance on sophisticated prompt engineering, and its core operational workflows.

== Overview

The aidev.py script is a conversational command-line tool that understands natural language requests. It automates the creation of new plugins and health checks by generating architecturally compliant, syntactically valid, and often technology-specific code.

Its primary capabilities include:

. Intent Recognition: Understanding user goals from plain English.
. Code Generation: Creating Python modules, SQL/query files, JSON rules, and unit tests.
. Architectural Compliance: Ensuring all generated code adheres to the framework's BasePlugin contract and established patterns.
. Automated Integration: Modifying report files to include newly created checks.
. Self-Correction: Automatically detecting and fixing syntax errors in the code it generates.

== High-Level Architecture

The agent operates on an "Intent Recognition -> Dispatch -> Handle" pattern, with a crucial self-correction loop integrated into the execution phase.

. Intent Recognition: The user's query is first sent to the AI via the intent_recognizer_prompt.adoc. The AI classifies the request into a specific intent (e.g., scaffold-plugin, generate-check) and extracts key entities (e.g., plugin name, natural language request).

. Dispatch: The main recognize_intent_and_dispatch function in aidev.py acts as a router. Based on the recognized intent, it calls the appropriate handler function (e.g., handle_scaffold_plugin, handle_generate_check).

. Handling & Plan Generation: The handler function uses a specialized prompt (e.g., plugin_scaffold_prompt.adoc, generate_check_prompt.adoc) to ask the AI to generate a detailed JSON "plan." This plan is a list of operations, typically create_directory and create_file actions, that describe the complete solution.

. Execution & Self-Correction: The execute_operations function iterates through the JSON plan.
** For create_file actions that produce Python code, the agent writes the file and then immediately validates it using the pyflakes linter.
** If syntax errors are found, it triggers a self-correction loop. It calls the AI again with the code_corrector_prompt.adoc, providing the faulty code and the linter errors.
** The AI returns a corrected version of the code, which the agent uses to overwrite the original file, ensuring all generated Python code is syntactically valid before the process completes.

. Code Integration: For generate-check operations, the plan includes an integration_step. The handle_code_integration function uses the code_modifier_prompt.adoc to ask the AI to intelligently insert the new check into the correct section of a report definition file.

== Prompt Engineering Strategy

The agent's intelligence is derived from a suite of specialized AsciiDoc prompt templates located in the templates/ directory. Each prompt is engineered to perform a specific task.

intent_recognizer_prompt.adoc:: 
Purpose: The "brain" of the agent. It classifies the user's raw input into a machine-readable intent and extracts entities.
Technique: Uses few-shot learning (providing multiple examples) to train the AI on the classification task.

plugin_scaffold_prompt.adoc::
Purpose: Generates the plan for creating a new, multi-file plugin skeleton.
Technique: Employs "Technology Analysis." It instructs the AI to analyze the target technology (e.g., Redis, MongoDB, SQL) and select the correct boilerplate from a library of examples within the prompt, leading to the generation of a functional, technology-aware connector.

generate_check_prompt.adoc::
Purpose: Generates the plan for creating a new, multi-file health check within an existing plugin.
Technique: Provides a highly detailed, multi-section specification covering architectural contracts, database interaction rules, query formatting for different technologies, code structure, and AsciiDoc formatting. This forces the AI's output to conform to the project's established patterns.

planner_prompt.adoc::
Purpose: Decomposes a single high-level request (e.g., "create comprehensive checks") into a multi-step plan.
Technique: Uses chain-of-thought prompting, forcing the AI to follow a mental process of deconstruction, brainstorming, and filtering before producing the final plan.

code_corrector_prompt.adoc & code_modifier_prompt.adoc::
Purpose: These are specialized, single-purpose prompts used for the self-correction and code integration steps, respectively. They provide the AI with the original code and a clear instruction for modification.

== Core Workflows

The agent has two primary workflows that demonstrate its end-to-end capabilities.

=== Workflow 1: Scaffolding a New Plugin

This workflow is used to create the entire directory structure and boilerplate for a new technology.

. User Input: 
- *_python3 aidev.py "scaffold a new plugin for Redis"_*
. Intent Recognition: 
- The agent recognizes the scaffold-plugin intent with "Redis" as the technology name.
. Plan Generation: 
- The handle_scaffold_plugin function uses plugin_scaffold_prompt.adoc. The AI analyzes "Redis", selects the Redis-specific connector boilerplate, and generates a JSON plan containing all the create_directory and create_file operations for __init__.py and a functional connector.py.
. Execution: 
- The agent creates the directories and files as specified in the plan, validating the syntax of the generated Python files and triggering self-correction if necessary.

=== Workflow 2: Generating a New Check

This workflow is used to add a new health check to an existing plugin.

. User Input:
- *_python3 aidev.py "add a redis check for memory fragmentation"_*
. Intent Recognition: 
- The agent recognizes the generate-check intent for the "redis" plugin.
. Plan Generation: 
- The handle_generate_check function uses generate_check_prompt.adoc. The AI, armed with extensive rules, generates a plan to create the check module, a JSON rule file, and a unit test file. It also creates an integration_step.
. Execution: 
- The agent creates the files, validating and self-correcting the Python code.
. Integration:
- The agent uses the integration_step to modify the plugins/redis/reports/default.py file, automatically adding the new check. If the report file doesn't exist, it creates a stub first.

== Usage

The aidev.py script is designed to be run from the tools/ directory.

.General Syntax: 
[source,bash]
python3 aidev.py "Your natural language request"

.Example: Create a New Plugin
[source,bash]
python3 aidev.py "scaffold a new plugin for ClickHouse"

.Example: Create a New Check 
[source,bash]
python3 aidev.py "add a clickhouse check for high memory usage queries"

.Example: Create a Comprehensive Set of Checks 
[source,bash]
python3 aidev.py "generate a comprehensive set of postgres health checks"
